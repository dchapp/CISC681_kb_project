import sympy as sp

"""
Find a symbol and its value if it appears only as a positive literal
(or only as a negative) in clauses
"""
def find_pure_symbol(symbols, unknown_clauses):
    for s in symbols:
        found_p, found_n = None, None
        for c in unknown_clauses:
            if not found_p and s in list(c.args):
                found_p = True
            if not found_n and sp.Not(s) in list(c.args):
                found_n = True
        if found_p != found_n:
            return s, found_p

    return None, None

"""
Find a unit clause--i.e. one with only a single bound variable in the model.
Note that a single-literal clause must have its variable bound in the model
and so counts as a unit clause.
"""
def find_unit_clause(clauses, model):
    for c in clauses:
        num_not_in_model = 0
        for s in list(c.args):
            if s not in model.keys():
                num_not_in_model += 1
                p, value = s, not (sp.Not(s))
        if num_not_in_model == 1:
            return p, value

    return None, None

        
"""
Return a set of clauses generated by:
1. Removing every clause containing a unit clause's single literal l
2. Removing ~l from every clause that contains ~l
"""
def unit_propagate(clauses, symbol):
    output = []
    for c in clauses:
        if type(c) == sp.Symbol or type(c) == sp.Not:
            output.append(c)
            continue
        for s in list(c.args):
            if s == sp.Not(symbol):
                pruned_clause = [x for x in list(c.args) if x != sp.Not(symbol)]
                output.append(sp.Or(*pruned_clause))
                break
            if s == symbol:
                break
        else:
            output.append(c)
    return output

"""
DPLL worker
"""
def dpll(clauses, symbols, model):
    ### Find all pure symbols possible
    p, value = find_pure_symbol(symbols, clauses)
    while p:
        symbols.remove(p)
        model[p] = value
        if value == False:
            p = sp.Not(p)
        p, value = find_pure_symbol(symbols, clauses)

    ### Find all unit clauses possible
    p, value = find_unit_clause(clauses, model)
    while p:
        symbols.remove(p)
        model[p] = value
        if value == False:
            p = sp.Not(p)
        p, value = find_unit_clause(clauses, model)

    ### Check if every clause is true in model
    ### If all are true, return True
    ### If at least one is false, return False
    num_true_in_model = 0
    for c in clauses:
        if model[c] == False:
            return False
        elif model[c] == True:
            num_true_in_model += 1
        else:
            continue
    if num_true_in_model == len(model.keys()):
        return True

    p = symbols.pop()
    model_p = dict(model)
    model_n = dict(model)
    model_p[p] = True
    model_n[p] = False
    symbols_p = list(symbols)
    symbols_n = list(symbols)
    return (dpll(clauses, symbols_p, model_p) or dpll(clauses, symbols_n, model_n))

"""
DPLL driver
"""
def dpll_satisfiable(kb, q):
    s = kb & sp.Not(q)
    clauses = list(s.args)
    symbols = []
    for c in clauses:
        args = list(c.args)
        new_symbols = []
        for a in args:
            if type(a) == sp.Symbol:
                new_symbols.append(a)
            else:
                new_symbols.append(sp.Not(a))
        symbols = symbols + new_symbols
    symbols = list(set(symbols))
    model = dict((c,-1) for c in clauses)
    return dpll(clauses, symbols, model)


       
